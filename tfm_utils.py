#
# Copyright 2023 David Haasler
#
# This file contains code generated by D. Haasler
#
# Version: Jun 27, 2023 @17:00
#
# SPDX-License-Identifier: GPL-3.0+
#

from astropy.io import fits
from astropy.nddata import CCDData
from astropy.stats import sigma_clipped_stats
import astropy.units as u
import matplotlib as mpl
import matplotlib.axes as maxes
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg, NavigationToolbar2Tk)
import matplotlib.patches as patches
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import tkinter as tk


def add_beam(
    ccdimage,
    ax,
    background=False,
    fill='hatch',
    color='white',
    x_corr=0,
    y_corr=0):
    """ Add beam to a image read from its fits header

    Parameters
    ----------
    ccdimage : astropy.nddata.ccddata.CCDData
        Image from which to read beam parameters.
    ax : astropy.visualization.wcsaxes.WCSAxesSubplot
        Axis into which the beam is inserted.
    background: bool
        If True, add white box background.
    fill : string
        String of characters to select fill inside the beam. Possible options are 'hatch' and 'solid'.
    color : str
        Facecolor of the beam.
    x_corr : float
        Displacement in pixels of the beam centre to the left.
    y_corr : float
        Displacement in pixels of the beam centre to the bottom.

    """

    x_lim = ax.get_xlim()
    y_lim = ax.get_ylim()
    beam_width = np.abs(ccdimage.header['BMIN'] / ccdimage.wcs.wcs.cdelt[0])    # in degrees
    beam_height = np.abs(ccdimage.header['BMAJ'] / ccdimage.wcs.wcs.cdelt[1])
    if beam_width < beam_height:
        distance = beam_height
    else:
        distance = beam_width
    # position is: axis start + percentage before ellipse + half of the ellipse's height or width (here width and height are interchanged because it is rotated 90ยบ)
    beam_centre = (x_lim[0] + (0.07 * (distance)) + distance/2 - x_corr, y_lim[0] + (0.07 * (distance)) + distance/2 - y_corr)
    beam_background_width = (2 * 0.07 * (distance)) + distance - 2*x_corr
    beam_background_height = (2 * 0.07 * (distance)) + distance - 2*y_corr
    beam_background = patches.Rectangle(xy=(x_lim[0], y_lim[0]), width=beam_background_width, height=beam_background_height, 
                edgecolor = 'black',
                facecolor = 'white',
                fill=True,
                lw=1)
    if fill == 'hatch':
        beam = patches.Ellipse(xy=beam_centre, width=beam_width, height=beam_height, angle=ccdimage.header['BPA'], 
                    edgecolor = 'black',
                    facecolor = color,
                    hatch='////',
                    fill=True,
                    lw=1)
    elif fill == 'solid':
        beam = patches.Ellipse(xy=beam_centre, width=beam_width, height=beam_height, angle=ccdimage.header['BPA'], 
                    edgecolor = color,
                    facecolor = color,
                    fill=True,
                    lw=1)
    if background:
        ax.add_patch(beam_background)
    ax.add_patch(beam)

    # Maybe use percentage instead of pixels for corrections


def add_continuum_peak(
    ax,
    ccdimage,
    ref_ccdimage,
    band,
    resolution,
    size=10,
    edgecolor='black',
    facecolor='blue',
    border=False):
    """ Add continuum emission peaks (manually selected in this function) to a map

    Parameters
    ----------
    ax : astropy.visualization.wcsaxes.WCSAxesSubplot
        Axis in which to draw continuum peaks for the cores.
    ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object into which to calculate coiordinates.
    ref_ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object from which to calculate coiordinates.
    band : string
        Select band to read center data of the cores.
    resolution : string
        Select resolution to read center data of the cores.
    size : int
        Size of the peak symbol.
    border : bool
        If true, display a square border around the center symbol.

    """

    if resolution == 'TM1':
        if band == '3':
            centerB = (1027, 1021)
            centerA = (957, 941)
        elif band == '4':
            centerB = (543, 539)
            centerA = (488, 476)
        elif band == '7':
            centerB = (283, 278)
            centerA = (225, 212)
        else:
            raise ValueError("Band must be '3', '4', or '7'")
    elif resolution == 'TM2':
        if band == '3':
            centerB = (225, 224)
            centerA = (210, 207)
        elif band == '4':
            centerB = (145, 144)
            centerA = (131, 128)
        elif band == '7':
            centerB = (98, 96)
            centerA = (78, 74)
        else:
            raise ValueError("Band must be '3', '4', or '7'")
    else:
        raise ValueError("Resolution must be 'TM1' (high) or 'TM2' (intermediate)")

    # Add continuum peak for core B
    new_rectB = coords_transformation(ccdimage=ccdimage, ref_ccdimage=ref_ccdimage, points=centerB)
    integrated_rectangleB = patches.Rectangle((new_rectB[0]-0.5, new_rectB[1]-0.5), -1, -1, 
                        edgecolor = edgecolor,
                        facecolor = facecolor,
                        fill=False,
                        lw=1.5)
    ax.scatter(new_rectB[0]-1, new_rectB[1]-1, marker='x', s=size, color=edgecolor)
    if border:
        ax.add_patch(integrated_rectangleB)
    # Add continuum peak for core A
    new_rectA = coords_transformation(ccdimage=ccdimage, ref_ccdimage=ref_ccdimage, points=centerA)
    integrated_rectangleA = patches.Rectangle((new_rectA[0]-0.5, new_rectA[1]-0.5), -1, -1, 
                        edgecolor = edgecolor,
                        facecolor = facecolor,
                        fill=False,
                        lw=1.5)
    ax.scatter(new_rectA[0]-1, new_rectA[1]-1, marker='x', s=size, color=edgecolor)
    if border:
        ax.add_patch(integrated_rectangleA)


def add_scalebar(
    ax,
    ccdimage,
    length,
    starting_point,
    capsize=0.01,
    label='default',
    labelpad=0.05,
    color='white'):
    """ Add a scalebar to a map

    Parameters
    ----------
    ax : astropy.visualization.wcsaxes.WCSAxesSubplot
        Axis in which to draw continuum peaks for the cores.
    ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object into which to calculate coordinates.
    length : astropy.units.quantity
        Distance from earth to object.
    starting_point : bidimensional array or list
        Point in the map coordinates form where to start drawing the scalebar.
    color : str
        Color for the scalebar.

    """

    # get necesary paremeters
    distance = 141*u.pc    # from Dzib et al 2018
    angular_size = 5*u.arcsec    # arbitrary
    physical_size = calculate_size(distance, angular_size)    # get physical size in AU of known angular size
    au_arcsec_rel = physical_size / angular_size.to(u.arcsec)    #get relation
    gain = ccdimage.wcs.wcs.cdelt[0]    # degrees per pixel

    # distance calculation
    distance_au = length.to(u.au)
    distance_angle = (distance_au / au_arcsec_rel)    # in arcsec
    distance_pix = distance_angle.to(u.deg).value / gain

    # scalebar definition
    scalebar = np.array([[starting_point[0], starting_point[1]], 
                         [starting_point[0]-np.absolute(distance_pix), starting_point[1]]])

    ax.plot(scalebar.T[0], scalebar.T[1], color=color)

    yrange = ax.get_ylim()[1]-ax.get_ylim()[0]
    ax.plot((starting_point[0], starting_point[0]), (starting_point[1]+capsize*yrange, starting_point[1]-capsize*yrange), color=color)
    ax.plot((starting_point[0]-np.absolute(distance_pix), starting_point[0]-np.absolute(distance_pix)), (starting_point[1]+capsize*yrange, starting_point[1]-capsize*yrange), color=color)
    if label == 'default':
        label = f'{length.value} {str(length.unit)}'
    ax.text(starting_point[0]-0.5*np.absolute(distance_pix), starting_point[1]-labelpad*yrange, label, color=color, ha='center', va='center')


def add_manual_wcs_axis(
    fig=None,
    ax_x_ini=0, 
    ax_y_ini=0, 
    ax_width=1, 
    ax_height=1,
    ccdimage=None,
    cbar=None,
    cbar_position='right',
    cbar_width='5%',
    cbar_pad=0.05,
    cmap='jet',
    norm='linear',
    vmin=0,
    vmax=100):
    """ Call add_subplot and return axis and image objects with WCS coordinates with colorbar

    A figure with no axes has to be set before calling this function.
    This is due to the inability to change an axis coordinates after it has been called.
    The coordinates have to be called when creating the axis object.

    Parameters
    ----------
    fig : matplotlib.figure.Figure
        Figure object.
    ax_x_ini : float
        X coordinate to begin axis.
    ax_y_ini : float
        Y coordinate to begin axis.
    ax_width : float
        Width of the axis.
    ax_height : float
        Height of the axis.
    ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object to be displayed.
    cbar : str or None
        Set type of colorbar to be added. Possible options are 'manual' and 'std'.
    cbar_position : str
        Set the location of cbar: 'right', 'top', 'left', 'bottom'.
    cbar_width : str
        Set percentage of axes box to use as width for cbar.
    cbar_pad : float
        Set the separation between cbar and axes box.
    cmap : matplotlib.colors.Colormap
        Select cmap to use.
    norm : str
        Normalisation for cmap.
    vmin : float
        Float number providing vmin for ax.imshow().
    vmax : float
        Float number providing vmax for ax.imshow().

    Return
    ------
    ax : astropy.visualization.wcsaxes.WCSAxesSubplot
        Axis object with the selected CCD image coordinates and map.
    img : matplotlib AxesImage
        Image object of the selected CCD image.

    """

    if cbar != 'std' and cbar != 'manual' and cbar != None:
        raise ValueError(f"Invalid input for cbar: '{cbar}'. Accepted values are 'std' or 'manual'")
    if vmin > vmax:
        raise ValueError(f"vmin ({vmin}) is higher than vmax ({vmax}). Change input values. Default values are vmin=0 and vmax=100")
    if ccdimage == None:
        raise TypeError(f"Need to specify a CCD_Data file with ccdimage keyword")
    
    data = ccdimage.data
    wcs = ccdimage.wcs

    # Drop extra dimensions if more than two are present (e.g freq and polarization (stokes))
    if wcs.naxis > 2:
        wcs = wcs.dropaxis(2)
        wcs = wcs.dropaxis(2)
    # Slice extra dimensions from data
    if ccdimage.header['NAXIS'] == 3:
        data = data[0, :, :]
    elif ccdimage.header['NAXIS'] == 4:
        data = data[0, 0, :, :]
    # Dimensions are: stokes, freq, Y, X for ALMA datacubes

    # Define color range with statistics
    if cbar == 'std':
        mean, median, std= sigma_clipped_stats(data, sigma=3.0)
        vmin = median - 3 * std
        vmax = median + 3 * std
        norm = 'linear'

    if norm == 'log' and vmin <= 0:
        raise ValueError(f"Cannot scale logarithmically with a negative number or zero")

    # Figure calling
    ax = fig.add_axes([ax_x_ini, ax_y_ini, ax_width, ax_height], projection=wcs)
    img = ax.imshow(data, vmin=vmin, vmax=vmax, cmap=cmap, origin='lower', norm=norm)
    ax.set_xlabel('RA (ICRS)')
    ax.set_ylabel('DEC (ICRS)')

    # Colorbar
    if cbar_position == 'left' or cbar_position == 'right':
        orientation = 'vertical'
    elif cbar_position == 'top' or cbar_position == 'bottom':
        orientation = 'horizontal'
    else:
        raise ValueError(f"cbar_position can only be 'top', 'right', 'vottom', or 'left'")
    
    # Colorbar
    if cbar == 'std' or cbar == 'manual':
        divider = make_axes_locatable(ax)
        cax = divider.append_axes(cbar_position, size=cbar_width, pad=cbar_pad, axes_class=maxes.Axes)   # axes_class=maxes.Axes to fix cbar problem
        if cbar_position == 'right':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='vertical')
        elif cbar_position == 'left':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='vertical')
            colorbar.ax.tick_params(axis="y",
                which="both",
                left=True,
                right=False,
                labelleft=True,
                labelright=False)
            colorbar.ax.yaxis.set_label_position('left')    # can also change axes coordinates to move freely.
            ax.coords[1].tick_params(axis="y",
                which="both",
                labelleft=False,
                labelright=True)
            ax.coords[1].set_axislabel_position('r')
        elif cbar_position == 'top':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='horizontal')
            colorbar.ax.tick_params(axis="x",
                which="both",
                top=True,
                bottom=False,
                labeltop=True,
                labelbottom=False)
            colorbar.ax.xaxis.set_label_position('top')    # can also change axes coordinates to move freely.
            ax.coords[0].tick_params(axis="x",
                which="both",
                labeltop=False,
                labelbottom=True)
            ax.coords[0].set_axislabel_position('b')
        elif cbar_position == 'bottom':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='horizontal')
            colorbar.ax.tick_params(axis="x",
                which="both",
                top=False,
                bottom=True,
                labeltop=False,
                labelbottom=True)
            colorbar.ax.xaxis.set_label_position('bottom')    # can also change axes coordinates to move freely.
            ax.coords[0].tick_params(axis="x",
                which="both",
                labeltop=True,
                labelbottom=False)
            ax.coords[0].set_axislabel_position('t')
        #colorbarbar.ax.set_ylabel(ylabel=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', fontsize=12)  # default 10
        #colorbarbar.ax.tick_params(labelsize=11)  # default 10

    if cbar == 'std' or cbar == 'manual':
        return ax, img, colorbar
    else:
        return ax, img


def add_wcs_axis(
    fig=None,
    nrows=1,
    ncols=1,
    number=1,
    ccdimage=None,
    cbar=None,
    cbar_position='right',
    cbar_width='5%',
    cbar_pad=0.05,
    cmap='jet',
    norm='linear',
    vmin=0,
    vmax=100):
    """ Call add_subplot and return axis and image objects with WCS coordinates with colorbar

    A figure with no axes has to be set before calling this function.
    This is due to the inability to change an axis coordinates after it has been called.
    The coordinates have to be called when creating the axis object.

    Parameters
    ----------
    fig : matplotlib.figure.Figure
        Figure object.
    nrows : int
        Number of rows on the subplot grid.
    ncols : int
        Number of columns on the subplot grid.
    number : int
        Number of subplot in the grid in which to paint the axis.
    ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object to be displayed.
    cbar : str or None
        Set type of colorbar to be added. Possible options are 'manual' and 'std'.
    cbar_position : str
        Set the location of cbar: 'right', 'top', 'left', 'bottom'.
    cbar_width : str
        Set percentage of axes box to use as width for cbar.
    cbar_pad : float
        Set the separation between cbar and axes box.
    cmap : matplotlib.colors.Colormap
        Select cmap to use.
    norm : str
        Normalisation for cmap.
    vmin : float
        Float number providing vmin for ax.imshow().
    vmax : float
        Float number providing vmax for ax.imshow().

    Return
    ------
    ax : astropy.visualization.wcsaxes.WCSAxesSubplot
        Axis object with the selected CCD image coordinates and map.
    img : matplotlib AxesImage
        Image object of the selected CCD image.

    """

    if cbar != 'std' and cbar != 'manual' and cbar != None:
        raise ValueError(f"Invalid input for cbar: '{cbar}'. Accepted values are 'std' or 'manual'")
    if vmin > vmax:
        raise ValueError(f"vmin ({vmin}) is higher than vmax ({vmax}). Change input values. Default values are vmin=0 and vmax=100")
    if ccdimage == None:
        raise TypeError(f"Need to specify a CCD_Data file with ccdimage keyword")
    
    data = ccdimage.data
    wcs = ccdimage.wcs

    # Drop extra dimensions if more than two are present (e.g freq and polarization (stokes))
    if wcs.naxis > 2:
        wcs = wcs.dropaxis(2)
        wcs = wcs.dropaxis(2)
    # Slice extra dimensions from data
    if ccdimage.header['NAXIS'] == 3:
        data = data[0, :, :]
    elif ccdimage.header['NAXIS'] == 4:
        data = data[0, 0, :, :]
    # Dimensions are: stokes, freq, Y, X

    # Define color range with statistics
    if cbar == 'std':
        mean, median, std= sigma_clipped_stats(data, sigma=3.0)
        vmin = median - 3 * std
        vmax = median + 3 * std
        norm = 'linear'

    if norm == 'log' and vmin <= 0:
        raise ValueError(f"Cannot scale logarithmically with a negative number or zero")

    # Figure calling
    ax = fig.add_subplot(nrows, ncols, number, projection=wcs)
    img = ax.imshow(data, vmin=vmin, vmax=vmax, cmap=cmap, origin='lower', norm=norm)
    ax.coords[0].set_axislabel("RA (ICRS)")
    ax.coords[1].set_axislabel("DEC (ICRS)")

    # Colorbar
    if cbar == 'std' or cbar == 'manual':
        divider = make_axes_locatable(ax)
        cax = divider.append_axes(cbar_position, size=cbar_width, pad=cbar_pad, axes_class=maxes.Axes)   # axes_class=maxes.Axes to fix cbar problem
        if cbar_position == 'right':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='vertical')
        elif cbar_position == 'left':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='vertical')
            colorbar.ax.tick_params(axis="y",
                which="both",
                left=True,
                right=False,
                labelleft=True,
                labelright=False)
            colorbar.ax.yaxis.set_label_position('left')    # can also change axes coordinates to move freely.
            ax.coords[1].tick_params(axis="y",
                which="both",
                labelleft=False,
                labelright=True)
            ax.coords[1].set_axislabel_position('r')
        elif cbar_position == 'top':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='horizontal')
            colorbar.ax.tick_params(axis="x",
                which="both",
                top=True,
                bottom=False,
                labeltop=True,
                labelbottom=False)
            colorbar.ax.xaxis.set_label_position('top')    # can also change axes coordinates to move freely.
            ax.coords[0].tick_params(axis="x",
                which="both",
                labeltop=False,
                labelbottom=True)
            ax.coords[0].set_axislabel_position('b')
        elif cbar_position == 'bottom':
            colorbar = fig.colorbar(img, cax=cax, label=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', orientation='horizontal')
            colorbar.ax.tick_params(axis="x",
                which="both",
                top=False,
                bottom=True,
                labeltop=False,
                labelbottom=True)
            colorbar.ax.xaxis.set_label_position('bottom')    # can also change axes coordinates to move freely.
            ax.coords[0].tick_params(axis="x",
                which="both",
                labeltop=True,
                labelbottom=False)
            ax.coords[0].set_axislabel_position('t')
        #colorbarbar.ax.set_ylabel(ylabel=r'$I \ {\rm (mJy \ beam^{-1} \ km \ s^{-1})}$', fontsize=12)  # default 10
        #colorbarbar.ax.tick_params(labelsize=11)  # default 10

    if cbar == 'std' or cbar == 'manual':
        return ax, img, colorbar
    else:
        return ax, img


def calculate_distance(
    points, 
    pointB,
    distance, 
    angular_size,
    ccdimage):
    """ Calculate pixel and physical distances between two points on a map

    Parameters
    ----------
    points : tuple or numpy.ndarray
        X and Y coordinates from a single point in a tuple or a collection of points in a [n, 2] sized numpy array.
    pointB : tuple
        X and Y coordinates from reference point at which to calculate distance.
    distance : astropy.units.quantity
        Distance from earth to object.
    angular_size : astropy.units.quantity
        Angle covered by the object in the sky.
    ccdimage : astropy.nddata.ccddata.CCDData
        CCDdata to get angular size of each pixel (CDELT1).

    Return
    ------
    distance_pix : tuple or numpy.ndarray
        Distance in pixels between points and pointB. 
    distance_au : astropy.units.Quantity
        Distance in AU between points and pointB. 

    """
 
    if isinstance(points, np.ndarray):
        points = np.transpose(points)
    
    side_x = np.absolute(points[0] - pointB[0])    # calculate sides of triangle
    side_y = np.absolute(points[1] - pointB[1])
    distance_pix = np.sqrt(side_x**2 + side_y**2)    # calculate hipotenuse (distance in pixels)
    
    # calculate relation between angular size and physical size at this distance
    physical_size = calculate_size(distance, angular_size)    # get physical size in AU of known angular size
    au_arcsec_rel = physical_size / angular_size.to(u.arcsec)    #get relation

    gain = ccdimage.wcs.wcs.cdelt[0]    # degrees per pixel
    distance_angle = np.absolute(distance_pix * gain) * u.deg    # get angular distance between points
    distance_au = distance_angle.to(u.arcsec) * au_arcsec_rel    # get distance in AU between points

    return distance_pix, distance_au


def calculate_size(
    distance, 
    angular_size):
    """ Calculate physical size of an object knowing its distance and angular size

    Parameters
    ----------
    distance : astropy.units.Quantity
        Distance from earth to object.
    angular_size : astropy.units.Quantity
        Angle covered by the object in the sky.

    Return
    ------
    physical_size : astropy.units.Quantity
        Physical size in AU corresponding to the angular size. 

    """

    if not isinstance(distance, u.Quantity):
        raise ValueError(f'Invalid type for distance: {type(distance)}. \n Needs to be : {u.Quantity}')
    if not isinstance(angular_size, u.Quantity):
        raise ValueError(f'Invalid type for distance: {type(angular_size)}. \n Needs to be : {u.Quantity}')
    physical_size = np.sin(angular_size)*distance.to(u.au)
    
    return physical_size


def calculate_sigma(ccdimage):
    """Calculate standard deviation (sigma) in a map

    Retuns sigma value calculated inside several polygons selected by
    mouse clicks in a CCDData object

    Parameters
    ----------
    ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object to analize.

    Return
    ------
    sigma : float
        Measured noise of the image.

    """

    # Create a Tkinter window
    root = tk.Tk()
    root.title("Sigma calculation")

    # Create a Matplotlib figure
    fig = mpl.figure.Figure(figsize=(8,8))  # mpl.pyplot.figure automatically shows inline plot
                                            # mpl.figure.Figure does not
    ax, img, cbar = add_wcs_axis(fig, 1, 1, 1, ccdimage=ccdimage, cbar='std', cmap='jet')

    # Lists to store the polygons, and arrays with pixel data
    polygons = []
    current_polygon = []
    inside_pixels = []

    # Create a callback function for mouse clicks
    def onclick(event):
        nonlocal polygons, current_polygon
        if event.button == 1:
            # Add the clicked point to the current polygon
            current_polygon.append((event.xdata, event.ydata))
            # Draw a small point at the first clicked point
            if len(now_polygon) == 1:
                ax.plot(event.xdata, event.ydata, 'white', marker='o', markersize=1)
            # Draw lines
            now_polygon = np.array(current_polygon)
            if len(now_polygon) > 1:
                ax.plot(now_polygon[-2:, 0], now_polygon[-2:, 1], 'white', lw=2, alpha=0.9)
            # Refresh the canvas
            canvas.draw()
        elif event.button == 3 and current_polygon:
            # Right-click to finalize the current polygon
            polygon = np.array(current_polygon)
            # Draw the last side of the polygon
            closed_polygon = np.vstack((polygon, polygon[0]))
            ax.plot(closed_polygon[-2:, 0], closed_polygon[-2:, 1], 'white', lw=2, alpha=0.9)
            # Draw the polygon on the plot
            poly = patches.Polygon(xy=polygon, linewidth=2, edgecolor='white', facecolor='white', alpha=0.5)
            new_poly=copy(poly)
            ax.add_patch(new_poly)
            # Get the shape of the CCDData object
            if ccdimage.header['NAXIS'] == 2:
                height, width = ccdimage.shape
            elif ccdimage.header['NAXIS'] == 3:
                freq, height, width = ccdimage.shape
            elif ccdimage.header['NAXIS'] == 4:
                freq, stokes, height, width = ccdimage.shape
            # Create a meshgrid of coordinates to create mask
            x, y = np.meshgrid(range(width), range(height))
            points = np.vstack((x.flatten(), y.flatten())).T
            mask = poly.contains_points(points, radius=0)   # mรกscara para marcar solo los que estรฉn dentro
            mask = mask.reshape((height, width))
            # Calculate std
            new_data = copy(ccdimage.data[0,0,:,:])
            std = new_data[mask].std()
            # Paint std inside polygon
            x_text = polygon.T[0].min()+(polygon.T[0].max()-polygon.T[0].min())/2
            y_text = polygon.T[1].min()+(polygon.T[1].max()-polygon.T[1].min())/2
            std_text = ax.text(x_text, y_text, f'{std:.2f}', va='center', ha='center', color='white', fontsize=13)
            std_text.set_path_effects([PathEffects.withStroke(linewidth=1.5, foreground='0.5')])
            # Add info on lists
            polygons.append(polygon)
            inside_pixels.append(new_data[mask])
            # Reset the current polygon
            current_polygon = []
            # Refresh the canvas
            canvas.draw()

    # Create a Matplotlib canvas embedded within the Tkinter window
    canvas = FigureCanvasTkAgg(fig, master=root)
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
    # Show toolbar
    toolbar = NavigationToolbar2Tk(canvas, root)
    toolbar.update()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
    # Add close button
    def _quit():
        root.quit()     # stops mainloop
        root.destroy()  # this is necessary on Windows to prevent
                        # Fatal Python Error: PyEval_RestoreThread: NULL tstate
    button = tk.Button(master=root, text="Quit", command=_quit)
    button.pack(side=tk.BOTTOM)
    # Add close shortcut
    def onkeypress(event):
        if event.key == 'q':
            root.quit()
            root.destroy()
    # Connect the onclick and onkeypress events to the canvas
    canvas.mpl_connect('button_press_event', onclick)
    canvas.mpl_connect('key_press_event', onkeypress)
    # Start the Tkinter event loop
    tk.mainloop()

    # Calculate sigma
    all_data = np.array([])
    for inside_data in inside_pixels:
        all_data = np.append(all_data, inside_data)
    sigma = np.std(all_data, ddof=0)
    print(f"sigma: {sigma}")

    return sigma


def calculate_sigma_boxes(ccdimage,
                    box1_coords,
                    box2_coords,
                    box3_coords,
                    show_map=False,
                    cmap='viridis',
                    cbar='std',
                    vmin=0,
                    vmax=100,
                    check_contour=False,
                    level=3,
                    linewidth=1,
                    save_directory=""):
    """Calculate standard deviation (sigma value) in a map at three given square regions

    Retuns sigma value and selected matplotlib.contour object if check_contour is True

    Parameters
    ----------
    ccdimage : astropy.nddata.ccddata.CCDData
        CCD Data object to analize.
    box1 : integer array
        x_min, x_max, y_min, and y_max delimiters of the box.
    box2 : integer array
        x_min, x_max, y_min, and y_max delimiters of the box.
    box3 : integer array
        x_min, x_max, y_min, and y_max delimiters of the box.
    show_map : bool
        If True, draw map with boxes and statistics.
    cmap : matplotlib.colors.Colormap
        Select cmap to use.
    cbar : str or None
        Set type of colorbar to be added. Possible options are 'manual' and 'std'.
    vmin : float
        Float number providing vmin for ax.imshow().
    vmax : float
        Float number providing vmax for ax.imshow().
    check_contour : bool
        If True, draw contour at selected sigma level.
    level : int
        Sigma level to plot in a contour.
    linewidth : float
        Linewidth for contour.
    save_directory : str or pathlib.PosixPath
        Directory in which to save the image.

    Return
    ------
    ax : astropy.visualization.wcsaxes.WCSAxesSubplot
        Instance returned by fig.add_wcs_axis()
    img : matplotlib AxesImage
        Instance returned by fig.add_wcs_axis()
    sigma : float
        Measured noise of the image.
    checked_contour : matplotlib.contour.QuadContourSet
        Contour of selected sigma value.

    """
    
    box_coords = [box1_coords, box2_coords, box3_coords]

    if check_contour:
        show_map = True    # To prevent error if check_contour is True but show map is False

    if show_map:
        fig = plt.figure(figsize=(6,6))
        ax, img, cbar = add_wcs_axis(fig, 1, 1, 1, ccdimage=ccdimage, cbar=cbar, vmin=vmin, vmax=vmax, cmap=cmap)
        for i in range(0,3):
            ax.plot((box_coords[i][0], box_coords[i][0]), (box_coords[i][2], box_coords[i][3]), 'white', lw=1)
            ax.plot((box_coords[i][1], box_coords[i][1]), (box_coords[i][2], box_coords[i][3]), 'white', lw=1)
            ax.plot((box_coords[i][0], box_coords[i][1]), (box_coords[i][2], box_coords[i][2]), 'white', lw=1)
            ax.plot((box_coords[i][0], box_coords[i][1]), (box_coords[i][3], box_coords[i][3]), 'white', lw=1)
            std = ccdimage.data[0, 0, box_coords[i][2]:box_coords[i][3], box_coords[i][0]:box_coords[i][1]].std()
            ax.text((box_coords[i][0]+box_coords[i][1])/2, (box_coords[i][3]+box_coords[i][2])/2,
                '{:.{prec}f}'.format(std, prec=1), 
                ha='center', va='center', color='white', fontsize=15)

    box1 = ccdimage.data[0, 0, box1_coords[2]:box1_coords[3], box1_coords[0]:box1_coords[1]]
    box2 = ccdimage.data[0, 0, box2_coords[2]:box2_coords[3], box2_coords[0]:box2_coords[1]]
    box3 = ccdimage.data[0, 0, box3_coords[2]:box3_coords[3], box3_coords[0]:box3_coords[1]]
    box1_flat = box1.flatten()
    box2_flat = box2.flatten()
    box3_flat = box3.flatten()
    todo = np.concatenate((box1_flat, box2_flat, box3_flat))
    sigma = np.std(todo, ddof=0)
    print(f'sigma = {sigma}')

    if check_contour:
        checked_contour = ax.contour(ccdimage.data[0, 0, :, :], [level*sigma], origin='lower', colors=['white'], linewidths=linewidth)
        plt.savefig(f'{save_directory}/sigma_contour.png', dpi=800)

        return ax, img, sigma, checked_contour
    else:
        return sigma


def coords_transformation(
    ccdimage,
    ref_ccdimage,
    points,
    coord_start1=1,
    coord_start2=1):
    """ Transform the pixel coordinates of a point from one image to another.

    Parameters
    ----------
    ccdimage : astropy.nddata.ccddata.CCDData
        Image into which the point is transformed.
    ref_ccdimage : astropy.nddata.ccddata.CCDData
        Reference Image.
    points : numpy array with points
        Point from ref_ccdimage to transform.

    Return
    ------
    new_points : int 2x1 array
        Transformed point returned. 

    """

    if ref_ccdimage.header['NAXIS'] == 2:
        # pixels to coordinates
        x_world, y_world = ref_ccdimage.wcs.wcs_pix2world(points[0], points[1], coord_start1)    # last number is where to begin counting. Python starts at 0 but FITS at 1.
        # coordinates to pixels from second image
        new_x, new_y = ccdimage.wcs.wcs_world2pix(x_world, y_world, coord_start2)
    elif ref_ccdimage.header['NAXIS'] == 4:
        # pixels to coordinates
        x_world, y_world, min_frec_world, min_pol_world = ref_ccdimage.wcs.wcs_pix2world(points[0], points[1], 1, 1, coord_start1)
        # coordinates to pixels from second image
        new_x, new_y, nul_frec_pix, nul_pol_pix = ccdimage.wcs.wcs_world2pix(x_world, y_world, min_frec_world, min_pol_world, coord_start2)
    
    new_points = np.array([new_x, new_y])

    return new_points


def get_input(fig):
    """ Get mouse click coordinates using a previous figure

    Parameters
    ----------
    fig : matplotlib.figure.Figure
        Figure object to show and from which to get coordinates.

    Return
    ------
    yroi : list
        List containing every point clicked in the image. 

    """
    
    # Change matplotlib backend to tkinter
    plt.switch_backend('TkAgg')

    # bring figure back from the dead
    new_fig = plt.figure()
    new_manager = new_fig.canvas.manager
    new_manager.canvas.figure = fig
    fig.set_canvas(new_manager.canvas) 

    yroi = fig.ginput(n=0,timeout=0, mouse_add=1, mouse_pop=2, mouse_stop=3)

    plt.close()

    # Change matplotlib backend back to inline
    plt.switch_backend('module://matplotlib_inline.backend_inline')

    return yroi


# CHANGE THIS FUNCTION TO AUTOMATICALLY CHANGE THE ZOOM LEVEL
def sync_zoom(
    ccdimage,
    ref_ccdimage,
    x_lim,
    y_lim,
    coord_start1=1,
    coord_start2=1):
    """ Transform a image's limit coordinates to another image.

    Parameters
    ----------
    ccdimage : astropy.nddata.ccddata.CCDData
        Image into which limits are transformed.
    ref_ccdimage : astropy.nddata.ccddata.CCDData
        Referente image.
    x_lim : int 2x1 array
        X axis limits from ref_ccdimage.
    y_lim : int 2x1 array
        Y axis limits from ref_ccdimage.
    coord_start1 : int
        starting coordinates from main image. Default fits standard: 1,1.
    coord_start2 : int
        starting coordinates from main image. Default fits standard: 1,1.

    Return
    ------
    new_x_lim : int 2x1 array
        Transformed X axis limits.
    new_y_lim : int 2x1 array
        Transformed Y axis limits.

    """

    if len(x_lim) != 2 or len(y_lim) != 2:
        raise TypeError(f"Limits need to be delimited by two coordinates each: (min, max)")
    if ref_ccdimage.header['NAXIS'] == 2:
        # pixels to coordinates
        xmin_world, ymin_world = ref_ccdimage.wcs.wcs_pix2world(x_lim[0], y_lim[0], coord_start1)
        xmax_world, ymax_world = ref_ccdimage.wcs.wcs_pix2world(x_lim[1], y_lim[1], coord_start1)
        # coordinates to pixels from second image
        xmin_2, ymin_2 = ccdimage.wcs.wcs_world2pix(xmin_world, ymin_world, coord_start2)
        xmax_2, ymax_2 = ccdimage.wcs.wcs_world2pix(xmax_world, ymax_world, coord_start2)
    elif ref_ccdimage.header['NAXIS'] == 4:
        # pixels to coordinates
        xmin_world, ymin_world, min_frec_world, min_pol_world = ref_ccdimage.wcs.wcs_pix2world(x_lim[0], y_lim[0], 1, 1, coord_start1)
        xmax_world, ymax_world, max_frec_world, max_pol_world = ref_ccdimage.wcs.wcs_pix2world(x_lim[1], y_lim[1], 1, 1, coord_start1)
        # coordinates to pixels from second image
        xmin_2, ymin_2, nul_frec_pix, nul_pol_pix = ccdimage.wcs.wcs_world2pix(xmin_world, ymin_world, min_frec_world, min_pol_world, coord_start2)
        xmax_2, ymax_2, nul_frec_pix, nul_pol_pix = ccdimage.wcs.wcs_world2pix(xmax_world, ymax_world, max_frec_world, max_pol_world, coord_start2)
    
    new_x_lim = [xmin_2, xmax_2]
    new_y_lim = [ymin_2, ymax_2]

    return new_x_lim, new_y_lim
